//autogenerated on 09/05/2017 11:07:31 PM
using System;
using System.Runtime.InteropServices;

namespace CSGL.Vulkan {
    public struct VkInstance : IEquatable<VkInstance> {
        public IntPtr native;

        public static VkInstance Null { get; } = new VkInstance();

        public override bool Equals(object other) {
            if (other is VkInstance) {
                return Equals((VkInstance)other);
            }
            return false;
        }

        public bool Equals(VkInstance other) {
            return other.native == native;
        }

        public static bool operator == (VkInstance a, VkInstance b) {
            return a.Equals(b);
        }

        public static bool operator != (VkInstance a, VkInstance b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPhysicalDevice : IEquatable<VkPhysicalDevice> {
        public IntPtr native;

        public static VkPhysicalDevice Null { get; } = new VkPhysicalDevice();

        public override bool Equals(object other) {
            if (other is VkPhysicalDevice) {
                return Equals((VkPhysicalDevice)other);
            }
            return false;
        }

        public bool Equals(VkPhysicalDevice other) {
            return other.native == native;
        }

        public static bool operator == (VkPhysicalDevice a, VkPhysicalDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPhysicalDevice a, VkPhysicalDevice b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDevice : IEquatable<VkDevice> {
        public IntPtr native;

        public static VkDevice Null { get; } = new VkDevice();

        public override bool Equals(object other) {
            if (other is VkDevice) {
                return Equals((VkDevice)other);
            }
            return false;
        }

        public bool Equals(VkDevice other) {
            return other.native == native;
        }

        public static bool operator == (VkDevice a, VkDevice b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDevice a, VkDevice b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkQueue : IEquatable<VkQueue> {
        public IntPtr native;

        public static VkQueue Null { get; } = new VkQueue();

        public override bool Equals(object other) {
            if (other is VkQueue) {
                return Equals((VkQueue)other);
            }
            return false;
        }

        public bool Equals(VkQueue other) {
            return other.native == native;
        }

        public static bool operator == (VkQueue a, VkQueue b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueue a, VkQueue b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkCommandBuffer : IEquatable<VkCommandBuffer> {
        public IntPtr native;

        public static VkCommandBuffer Null { get; } = new VkCommandBuffer();

        public override bool Equals(object other) {
            if (other is VkCommandBuffer) {
                return Equals((VkCommandBuffer)other);
            }
            return false;
        }

        public bool Equals(VkCommandBuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkCommandBuffer a, VkCommandBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandBuffer a, VkCommandBuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDeviceMemory : IEquatable<VkDeviceMemory> {
        public ulong native;

        public static VkDeviceMemory Null { get; } = new VkDeviceMemory();

        public override bool Equals(object other) {
            if (other is VkDeviceMemory) {
                return Equals((VkDeviceMemory)other);
            }
            return false;
        }

        public bool Equals(VkDeviceMemory other) {
            return other.native == native;
        }

        public static bool operator == (VkDeviceMemory a, VkDeviceMemory b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDeviceMemory a, VkDeviceMemory b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkCommandPool : IEquatable<VkCommandPool> {
        public ulong native;

        public static VkCommandPool Null { get; } = new VkCommandPool();

        public override bool Equals(object other) {
            if (other is VkCommandPool) {
                return Equals((VkCommandPool)other);
            }
            return false;
        }

        public bool Equals(VkCommandPool other) {
            return other.native == native;
        }

        public static bool operator == (VkCommandPool a, VkCommandPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkCommandPool a, VkCommandPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkBuffer : IEquatable<VkBuffer> {
        public ulong native;

        public static VkBuffer Null { get; } = new VkBuffer();

        public override bool Equals(object other) {
            if (other is VkBuffer) {
                return Equals((VkBuffer)other);
            }
            return false;
        }

        public bool Equals(VkBuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkBuffer a, VkBuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBuffer a, VkBuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkBufferView : IEquatable<VkBufferView> {
        public ulong native;

        public static VkBufferView Null { get; } = new VkBufferView();

        public override bool Equals(object other) {
            if (other is VkBufferView) {
                return Equals((VkBufferView)other);
            }
            return false;
        }

        public bool Equals(VkBufferView other) {
            return other.native == native;
        }

        public static bool operator == (VkBufferView a, VkBufferView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkBufferView a, VkBufferView b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkImage : IEquatable<VkImage> {
        public ulong native;

        public static VkImage Null { get; } = new VkImage();

        public override bool Equals(object other) {
            if (other is VkImage) {
                return Equals((VkImage)other);
            }
            return false;
        }

        public bool Equals(VkImage other) {
            return other.native == native;
        }

        public static bool operator == (VkImage a, VkImage b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImage a, VkImage b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkImageView : IEquatable<VkImageView> {
        public ulong native;

        public static VkImageView Null { get; } = new VkImageView();

        public override bool Equals(object other) {
            if (other is VkImageView) {
                return Equals((VkImageView)other);
            }
            return false;
        }

        public bool Equals(VkImageView other) {
            return other.native == native;
        }

        public static bool operator == (VkImageView a, VkImageView b) {
            return a.Equals(b);
        }

        public static bool operator != (VkImageView a, VkImageView b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkShaderModule : IEquatable<VkShaderModule> {
        public ulong native;

        public static VkShaderModule Null { get; } = new VkShaderModule();

        public override bool Equals(object other) {
            if (other is VkShaderModule) {
                return Equals((VkShaderModule)other);
            }
            return false;
        }

        public bool Equals(VkShaderModule other) {
            return other.native == native;
        }

        public static bool operator == (VkShaderModule a, VkShaderModule b) {
            return a.Equals(b);
        }

        public static bool operator != (VkShaderModule a, VkShaderModule b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipeline : IEquatable<VkPipeline> {
        public ulong native;

        public static VkPipeline Null { get; } = new VkPipeline();

        public override bool Equals(object other) {
            if (other is VkPipeline) {
                return Equals((VkPipeline)other);
            }
            return false;
        }

        public bool Equals(VkPipeline other) {
            return other.native == native;
        }

        public static bool operator == (VkPipeline a, VkPipeline b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipeline a, VkPipeline b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipelineLayout : IEquatable<VkPipelineLayout> {
        public ulong native;

        public static VkPipelineLayout Null { get; } = new VkPipelineLayout();

        public override bool Equals(object other) {
            if (other is VkPipelineLayout) {
                return Equals((VkPipelineLayout)other);
            }
            return false;
        }

        public bool Equals(VkPipelineLayout other) {
            return other.native == native;
        }

        public static bool operator == (VkPipelineLayout a, VkPipelineLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineLayout a, VkPipelineLayout b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSampler : IEquatable<VkSampler> {
        public ulong native;

        public static VkSampler Null { get; } = new VkSampler();

        public override bool Equals(object other) {
            if (other is VkSampler) {
                return Equals((VkSampler)other);
            }
            return false;
        }

        public bool Equals(VkSampler other) {
            return other.native == native;
        }

        public static bool operator == (VkSampler a, VkSampler b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSampler a, VkSampler b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorSet : IEquatable<VkDescriptorSet> {
        public ulong native;

        public static VkDescriptorSet Null { get; } = new VkDescriptorSet();

        public override bool Equals(object other) {
            if (other is VkDescriptorSet) {
                return Equals((VkDescriptorSet)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorSet other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorSet a, VkDescriptorSet b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSet a, VkDescriptorSet b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorSetLayout : IEquatable<VkDescriptorSetLayout> {
        public ulong native;

        public static VkDescriptorSetLayout Null { get; } = new VkDescriptorSetLayout();

        public override bool Equals(object other) {
            if (other is VkDescriptorSetLayout) {
                return Equals((VkDescriptorSetLayout)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorSetLayout other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorSetLayout a, VkDescriptorSetLayout b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDescriptorPool : IEquatable<VkDescriptorPool> {
        public ulong native;

        public static VkDescriptorPool Null { get; } = new VkDescriptorPool();

        public override bool Equals(object other) {
            if (other is VkDescriptorPool) {
                return Equals((VkDescriptorPool)other);
            }
            return false;
        }

        public bool Equals(VkDescriptorPool other) {
            return other.native == native;
        }

        public static bool operator == (VkDescriptorPool a, VkDescriptorPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDescriptorPool a, VkDescriptorPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkFence : IEquatable<VkFence> {
        public ulong native;

        public static VkFence Null { get; } = new VkFence();

        public override bool Equals(object other) {
            if (other is VkFence) {
                return Equals((VkFence)other);
            }
            return false;
        }

        public bool Equals(VkFence other) {
            return other.native == native;
        }

        public static bool operator == (VkFence a, VkFence b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFence a, VkFence b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSemaphore : IEquatable<VkSemaphore> {
        public ulong native;

        public static VkSemaphore Null { get; } = new VkSemaphore();

        public override bool Equals(object other) {
            if (other is VkSemaphore) {
                return Equals((VkSemaphore)other);
            }
            return false;
        }

        public bool Equals(VkSemaphore other) {
            return other.native == native;
        }

        public static bool operator == (VkSemaphore a, VkSemaphore b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSemaphore a, VkSemaphore b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkEvent : IEquatable<VkEvent> {
        public ulong native;

        public static VkEvent Null { get; } = new VkEvent();

        public override bool Equals(object other) {
            if (other is VkEvent) {
                return Equals((VkEvent)other);
            }
            return false;
        }

        public bool Equals(VkEvent other) {
            return other.native == native;
        }

        public static bool operator == (VkEvent a, VkEvent b) {
            return a.Equals(b);
        }

        public static bool operator != (VkEvent a, VkEvent b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkQueryPool : IEquatable<VkQueryPool> {
        public ulong native;

        public static VkQueryPool Null { get; } = new VkQueryPool();

        public override bool Equals(object other) {
            if (other is VkQueryPool) {
                return Equals((VkQueryPool)other);
            }
            return false;
        }

        public bool Equals(VkQueryPool other) {
            return other.native == native;
        }

        public static bool operator == (VkQueryPool a, VkQueryPool b) {
            return a.Equals(b);
        }

        public static bool operator != (VkQueryPool a, VkQueryPool b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkFramebuffer : IEquatable<VkFramebuffer> {
        public ulong native;

        public static VkFramebuffer Null { get; } = new VkFramebuffer();

        public override bool Equals(object other) {
            if (other is VkFramebuffer) {
                return Equals((VkFramebuffer)other);
            }
            return false;
        }

        public bool Equals(VkFramebuffer other) {
            return other.native == native;
        }

        public static bool operator == (VkFramebuffer a, VkFramebuffer b) {
            return a.Equals(b);
        }

        public static bool operator != (VkFramebuffer a, VkFramebuffer b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkRenderPass : IEquatable<VkRenderPass> {
        public ulong native;

        public static VkRenderPass Null { get; } = new VkRenderPass();

        public override bool Equals(object other) {
            if (other is VkRenderPass) {
                return Equals((VkRenderPass)other);
            }
            return false;
        }

        public bool Equals(VkRenderPass other) {
            return other.native == native;
        }

        public static bool operator == (VkRenderPass a, VkRenderPass b) {
            return a.Equals(b);
        }

        public static bool operator != (VkRenderPass a, VkRenderPass b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkPipelineCache : IEquatable<VkPipelineCache> {
        public ulong native;

        public static VkPipelineCache Null { get; } = new VkPipelineCache();

        public override bool Equals(object other) {
            if (other is VkPipelineCache) {
                return Equals((VkPipelineCache)other);
            }
            return false;
        }

        public bool Equals(VkPipelineCache other) {
            return other.native == native;
        }

        public static bool operator == (VkPipelineCache a, VkPipelineCache b) {
            return a.Equals(b);
        }

        public static bool operator != (VkPipelineCache a, VkPipelineCache b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDisplayKHR : IEquatable<VkDisplayKHR> {
        public ulong native;

        public static VkDisplayKHR Null { get; } = new VkDisplayKHR();

        public override bool Equals(object other) {
            if (other is VkDisplayKHR) {
                return Equals((VkDisplayKHR)other);
            }
            return false;
        }

        public bool Equals(VkDisplayKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkDisplayKHR a, VkDisplayKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayKHR a, VkDisplayKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDisplayModeKHR : IEquatable<VkDisplayModeKHR> {
        public ulong native;

        public static VkDisplayModeKHR Null { get; } = new VkDisplayModeKHR();

        public override bool Equals(object other) {
            if (other is VkDisplayModeKHR) {
                return Equals((VkDisplayModeKHR)other);
            }
            return false;
        }

        public bool Equals(VkDisplayModeKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDisplayModeKHR a, VkDisplayModeKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSurfaceKHR : IEquatable<VkSurfaceKHR> {
        public ulong native;

        public static VkSurfaceKHR Null { get; } = new VkSurfaceKHR();

        public override bool Equals(object other) {
            if (other is VkSurfaceKHR) {
                return Equals((VkSurfaceKHR)other);
            }
            return false;
        }

        public bool Equals(VkSurfaceKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkSurfaceKHR a, VkSurfaceKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSurfaceKHR a, VkSurfaceKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkSwapchainKHR : IEquatable<VkSwapchainKHR> {
        public ulong native;

        public static VkSwapchainKHR Null { get; } = new VkSwapchainKHR();

        public override bool Equals(object other) {
            if (other is VkSwapchainKHR) {
                return Equals((VkSwapchainKHR)other);
            }
            return false;
        }

        public bool Equals(VkSwapchainKHR other) {
            return other.native == native;
        }

        public static bool operator == (VkSwapchainKHR a, VkSwapchainKHR b) {
            return a.Equals(b);
        }

        public static bool operator != (VkSwapchainKHR a, VkSwapchainKHR b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    public struct VkDebugReportCallbackEXT : IEquatable<VkDebugReportCallbackEXT> {
        public ulong native;

        public static VkDebugReportCallbackEXT Null { get; } = new VkDebugReportCallbackEXT();

        public override bool Equals(object other) {
            if (other is VkDebugReportCallbackEXT) {
                return Equals((VkDebugReportCallbackEXT)other);
            }
            return false;
        }

        public bool Equals(VkDebugReportCallbackEXT other) {
            return other.native == native;
        }

        public static bool operator == (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return a.Equals(b);
        }

        public static bool operator != (VkDebugReportCallbackEXT a, VkDebugReportCallbackEXT b) {
            return !(a == b);
        }

        public override int GetHashCode() {
            return native.GetHashCode();
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkOffset2D {
        [FieldOffset(0)]
        public int x;
        [FieldOffset(4)]
        public int y;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkOffset3D {
        [FieldOffset(0)]
        public int x;
        [FieldOffset(4)]
        public int y;
        [FieldOffset(8)]
        public int z;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkExtent2D {
        [FieldOffset(0)]
        public uint width;
        [FieldOffset(4)]
        public uint height;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkExtent3D {
        [FieldOffset(0)]
        public uint width;
        [FieldOffset(4)]
        public uint height;
        [FieldOffset(8)]
        public uint depth;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkViewport {
        [FieldOffset(0)]
        public float x;
        [FieldOffset(4)]
        public float y;
        [FieldOffset(8)]
        public float width;
        [FieldOffset(12)]
        public float height;
        [FieldOffset(16)]
        public float minDepth;
        [FieldOffset(20)]
        public float maxDepth;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkRect2D {
        [FieldOffset(0)]
        public VkOffset2D offset;
        [FieldOffset(8)]
        public VkExtent2D extent;
    }

    public partial struct VkRect3D {
        public VkOffset3D offset;
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkClearRect {
        [FieldOffset(0)]
        public VkRect2D rect;
        [FieldOffset(16)]
        public uint baseArrayLayer;
        [FieldOffset(20)]
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkComponentMapping {
        [FieldOffset(0)]
        public VkComponentSwizzle r;
        [FieldOffset(4)]
        public VkComponentSwizzle g;
        [FieldOffset(8)]
        public VkComponentSwizzle b;
        [FieldOffset(12)]
        public VkComponentSwizzle a;
    }

    [StructLayout(LayoutKind.Explicit, Size = 824)]
    public partial struct VkPhysicalDeviceProperties {
        [FieldOffset(0)]
        public uint apiVersion;
        [FieldOffset(4)]
        public uint driverVersion;
        [FieldOffset(8)]
        public uint vendorID;
        [FieldOffset(12)]
        public uint deviceID;
        [FieldOffset(16)]
        public VkPhysicalDeviceType deviceType;
        [FieldOffset(20)]
        public byte deviceName;
        [FieldOffset(276)]
        public byte pipelineCacheUUID;
        [FieldOffset(296)]
        public VkPhysicalDeviceLimits limits;
        [FieldOffset(800)]
        public VkPhysicalDeviceSparseProperties sparseProperties;
    }

    [StructLayout(LayoutKind.Explicit, Size = 260)]
    public partial struct VkExtensionProperties {
        [FieldOffset(0)]
        public byte extensionName;
        [FieldOffset(256)]
        public VkVersion specVersion;
    }

    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public partial struct VkLayerProperties {
        [FieldOffset(0)]
        public byte layerName;
        [FieldOffset(256)]
        public VkVersion specVersion;
        [FieldOffset(260)]
        public uint implementationVersion;
        [FieldOffset(264)]
        public byte description;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkApplicationInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public IntPtr pApplicationName;
        [FieldOffset(24)]
        public VkVersion applicationVersion;
        [FieldOffset(32)]
        public IntPtr pEngineName;
        [FieldOffset(40)]
        public VkVersion engineVersion;
        [FieldOffset(44)]
        public VkVersion apiVersion;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkAllocationCallbacks {
        [FieldOffset(0)]
        public IntPtr pUserData;
        [FieldOffset(8)]
        public IntPtr pfnAllocation;
        [FieldOffset(16)]
        public IntPtr pfnReallocation;
        [FieldOffset(24)]
        public IntPtr pfnFree;
        [FieldOffset(32)]
        public IntPtr pfnInternalAllocation;
        [FieldOffset(40)]
        public IntPtr pfnInternalFree;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkDeviceQueueCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDeviceQueueCreateFlags flags;
        [FieldOffset(20)]
        public uint queueFamilyIndex;
        [FieldOffset(24)]
        public uint queueCount;
        [FieldOffset(32)]
        public IntPtr pQueuePriorities;
    }

    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct VkDeviceCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDeviceCreateFlags flags;
        [FieldOffset(20)]
        public uint queueCreateInfoCount;
        [FieldOffset(24)]
        public IntPtr pQueueCreateInfos;
        [FieldOffset(32)]
        public uint enabledLayerCount;
        [FieldOffset(40)]
        public IntPtr ppEnabledLayerNames;
        [FieldOffset(48)]
        public uint enabledExtensionCount;
        [FieldOffset(56)]
        public IntPtr ppEnabledExtensionNames;
        [FieldOffset(64)]
        public IntPtr pEnabledFeatures;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkInstanceCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkInstanceCreateFlags flags;
        [FieldOffset(24)]
        public IntPtr pApplicationInfo;
        [FieldOffset(32)]
        public uint enabledLayerCount;
        [FieldOffset(40)]
        public IntPtr ppEnabledLayerNames;
        [FieldOffset(48)]
        public uint enabledExtensionCount;
        [FieldOffset(56)]
        public IntPtr ppEnabledExtensionNames;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkQueueFamilyProperties {
        [FieldOffset(0)]
        public VkQueueFlags queueFlags;
        [FieldOffset(4)]
        public uint queueCount;
        [FieldOffset(8)]
        public uint timestampValidBits;
        [FieldOffset(12)]
        public VkExtent3D minImageTransferGranularity;
    }

    [StructLayout(LayoutKind.Explicit, Size = 520)]
    public partial struct VkPhysicalDeviceMemoryProperties {
        [FieldOffset(0)]
        public uint memoryTypeCount;
        [FieldOffset(4)]
        public VkMemoryType memoryTypes_0;
        [FieldOffset(12)]
        public VkMemoryType memoryTypes_1;
        [FieldOffset(20)]
        public VkMemoryType memoryTypes_2;
        [FieldOffset(28)]
        public VkMemoryType memoryTypes_3;
        [FieldOffset(36)]
        public VkMemoryType memoryTypes_4;
        [FieldOffset(44)]
        public VkMemoryType memoryTypes_5;
        [FieldOffset(52)]
        public VkMemoryType memoryTypes_6;
        [FieldOffset(60)]
        public VkMemoryType memoryTypes_7;
        [FieldOffset(68)]
        public VkMemoryType memoryTypes_8;
        [FieldOffset(76)]
        public VkMemoryType memoryTypes_9;
        [FieldOffset(84)]
        public VkMemoryType memoryTypes_10;
        [FieldOffset(92)]
        public VkMemoryType memoryTypes_11;
        [FieldOffset(100)]
        public VkMemoryType memoryTypes_12;
        [FieldOffset(108)]
        public VkMemoryType memoryTypes_13;
        [FieldOffset(116)]
        public VkMemoryType memoryTypes_14;
        [FieldOffset(124)]
        public VkMemoryType memoryTypes_15;
        [FieldOffset(132)]
        public VkMemoryType memoryTypes_16;
        [FieldOffset(140)]
        public VkMemoryType memoryTypes_17;
        [FieldOffset(148)]
        public VkMemoryType memoryTypes_18;
        [FieldOffset(156)]
        public VkMemoryType memoryTypes_19;
        [FieldOffset(164)]
        public VkMemoryType memoryTypes_20;
        [FieldOffset(172)]
        public VkMemoryType memoryTypes_21;
        [FieldOffset(180)]
        public VkMemoryType memoryTypes_22;
        [FieldOffset(188)]
        public VkMemoryType memoryTypes_23;
        [FieldOffset(196)]
        public VkMemoryType memoryTypes_24;
        [FieldOffset(204)]
        public VkMemoryType memoryTypes_25;
        [FieldOffset(212)]
        public VkMemoryType memoryTypes_26;
        [FieldOffset(220)]
        public VkMemoryType memoryTypes_27;
        [FieldOffset(228)]
        public VkMemoryType memoryTypes_28;
        [FieldOffset(236)]
        public VkMemoryType memoryTypes_29;
        [FieldOffset(244)]
        public VkMemoryType memoryTypes_30;
        [FieldOffset(252)]
        public VkMemoryType memoryTypes_31;

        public VkMemoryType GetMemoryTypes(int i) {
            switch (i) {
                case 0: return memoryTypes_0;
                case 1: return memoryTypes_1;
                case 2: return memoryTypes_2;
                case 3: return memoryTypes_3;
                case 4: return memoryTypes_4;
                case 5: return memoryTypes_5;
                case 6: return memoryTypes_6;
                case 7: return memoryTypes_7;
                case 8: return memoryTypes_8;
                case 9: return memoryTypes_9;
                case 10: return memoryTypes_10;
                case 11: return memoryTypes_11;
                case 12: return memoryTypes_12;
                case 13: return memoryTypes_13;
                case 14: return memoryTypes_14;
                case 15: return memoryTypes_15;
                case 16: return memoryTypes_16;
                case 17: return memoryTypes_17;
                case 18: return memoryTypes_18;
                case 19: return memoryTypes_19;
                case 20: return memoryTypes_20;
                case 21: return memoryTypes_21;
                case 22: return memoryTypes_22;
                case 23: return memoryTypes_23;
                case 24: return memoryTypes_24;
                case 25: return memoryTypes_25;
                case 26: return memoryTypes_26;
                case 27: return memoryTypes_27;
                case 28: return memoryTypes_28;
                case 29: return memoryTypes_29;
                case 30: return memoryTypes_30;
                case 31: return memoryTypes_31;
                default: return default(VkMemoryType);
            }
        }

        public void SetMemoryTypes(int i, VkMemoryType value) {
            switch (i) {
                case 0: memoryTypes_0 = value; break;
                case 1: memoryTypes_1 = value; break;
                case 2: memoryTypes_2 = value; break;
                case 3: memoryTypes_3 = value; break;
                case 4: memoryTypes_4 = value; break;
                case 5: memoryTypes_5 = value; break;
                case 6: memoryTypes_6 = value; break;
                case 7: memoryTypes_7 = value; break;
                case 8: memoryTypes_8 = value; break;
                case 9: memoryTypes_9 = value; break;
                case 10: memoryTypes_10 = value; break;
                case 11: memoryTypes_11 = value; break;
                case 12: memoryTypes_12 = value; break;
                case 13: memoryTypes_13 = value; break;
                case 14: memoryTypes_14 = value; break;
                case 15: memoryTypes_15 = value; break;
                case 16: memoryTypes_16 = value; break;
                case 17: memoryTypes_17 = value; break;
                case 18: memoryTypes_18 = value; break;
                case 19: memoryTypes_19 = value; break;
                case 20: memoryTypes_20 = value; break;
                case 21: memoryTypes_21 = value; break;
                case 22: memoryTypes_22 = value; break;
                case 23: memoryTypes_23 = value; break;
                case 24: memoryTypes_24 = value; break;
                case 25: memoryTypes_25 = value; break;
                case 26: memoryTypes_26 = value; break;
                case 27: memoryTypes_27 = value; break;
                case 28: memoryTypes_28 = value; break;
                case 29: memoryTypes_29 = value; break;
                case 30: memoryTypes_30 = value; break;
                case 31: memoryTypes_31 = value; break;
                default: return;
            }
        }
        [FieldOffset(260)]
        public uint memoryHeapCount;
        [FieldOffset(264)]
        public VkMemoryHeap memoryHeaps_0;
        [FieldOffset(280)]
        public VkMemoryHeap memoryHeaps_1;
        [FieldOffset(296)]
        public VkMemoryHeap memoryHeaps_2;
        [FieldOffset(312)]
        public VkMemoryHeap memoryHeaps_3;
        [FieldOffset(328)]
        public VkMemoryHeap memoryHeaps_4;
        [FieldOffset(344)]
        public VkMemoryHeap memoryHeaps_5;
        [FieldOffset(360)]
        public VkMemoryHeap memoryHeaps_6;
        [FieldOffset(376)]
        public VkMemoryHeap memoryHeaps_7;
        [FieldOffset(392)]
        public VkMemoryHeap memoryHeaps_8;
        [FieldOffset(408)]
        public VkMemoryHeap memoryHeaps_9;
        [FieldOffset(424)]
        public VkMemoryHeap memoryHeaps_10;
        [FieldOffset(440)]
        public VkMemoryHeap memoryHeaps_11;
        [FieldOffset(456)]
        public VkMemoryHeap memoryHeaps_12;
        [FieldOffset(472)]
        public VkMemoryHeap memoryHeaps_13;
        [FieldOffset(488)]
        public VkMemoryHeap memoryHeaps_14;
        [FieldOffset(504)]
        public VkMemoryHeap memoryHeaps_15;

        public VkMemoryHeap GetMemoryHeaps(int i) {
            switch (i) {
                case 0: return memoryHeaps_0;
                case 1: return memoryHeaps_1;
                case 2: return memoryHeaps_2;
                case 3: return memoryHeaps_3;
                case 4: return memoryHeaps_4;
                case 5: return memoryHeaps_5;
                case 6: return memoryHeaps_6;
                case 7: return memoryHeaps_7;
                case 8: return memoryHeaps_8;
                case 9: return memoryHeaps_9;
                case 10: return memoryHeaps_10;
                case 11: return memoryHeaps_11;
                case 12: return memoryHeaps_12;
                case 13: return memoryHeaps_13;
                case 14: return memoryHeaps_14;
                case 15: return memoryHeaps_15;
                default: return default(VkMemoryHeap);
            }
        }

        public void SetMemoryHeaps(int i, VkMemoryHeap value) {
            switch (i) {
                case 0: memoryHeaps_0 = value; break;
                case 1: memoryHeaps_1 = value; break;
                case 2: memoryHeaps_2 = value; break;
                case 3: memoryHeaps_3 = value; break;
                case 4: memoryHeaps_4 = value; break;
                case 5: memoryHeaps_5 = value; break;
                case 6: memoryHeaps_6 = value; break;
                case 7: memoryHeaps_7 = value; break;
                case 8: memoryHeaps_8 = value; break;
                case 9: memoryHeaps_9 = value; break;
                case 10: memoryHeaps_10 = value; break;
                case 11: memoryHeaps_11 = value; break;
                case 12: memoryHeaps_12 = value; break;
                case 13: memoryHeaps_13 = value; break;
                case 14: memoryHeaps_14 = value; break;
                case 15: memoryHeaps_15 = value; break;
                default: return;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkMemoryAllocateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public ulong allocationSize;
        [FieldOffset(24)]
        public uint memoryTypeIndex;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkMemoryRequirements {
        [FieldOffset(0)]
        public ulong size;
        [FieldOffset(8)]
        public ulong alignment;
        [FieldOffset(16)]
        public uint memoryTypeBits;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct VkSparseImageFormatProperties {
        [FieldOffset(0)]
        public VkImageAspectFlags aspectMask;
        [FieldOffset(4)]
        public VkExtent3D imageGranularity;
        [FieldOffset(16)]
        public VkSparseImageFormatFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkSparseImageMemoryRequirements {
        [FieldOffset(0)]
        public VkSparseImageFormatProperties formatProperties;
        [FieldOffset(20)]
        public uint imageMipTailFirstLod;
        [FieldOffset(24)]
        public ulong imageMipTailSize;
        [FieldOffset(32)]
        public ulong imageMipTailOffset;
        [FieldOffset(40)]
        public ulong imageMipTailStride;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkMemoryType {
        [FieldOffset(0)]
        public VkMemoryPropertyFlags propertyFlags;
        [FieldOffset(4)]
        public uint heapIndex;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkMemoryHeap {
        [FieldOffset(0)]
        public ulong size;
        [FieldOffset(8)]
        public VkMemoryHeapFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkMappedMemoryRange {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDeviceMemory memory;
        [FieldOffset(24)]
        public ulong offset;
        [FieldOffset(32)]
        public ulong size;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkFormatProperties {
        [FieldOffset(0)]
        public VkFormatFeatureFlags linearTilingFeatures;
        [FieldOffset(4)]
        public VkFormatFeatureFlags optimalTilingFeatures;
        [FieldOffset(8)]
        public VkFormatFeatureFlags bufferFeatures;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkImageFormatProperties {
        [FieldOffset(0)]
        public VkExtent3D maxExtent;
        [FieldOffset(12)]
        public uint maxMipLevels;
        [FieldOffset(16)]
        public uint maxArrayLayers;
        [FieldOffset(20)]
        public VkSampleCountFlags sampleCounts;
        [FieldOffset(24)]
        public ulong maxResourceSize;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkDescriptorBufferInfo {
        [FieldOffset(0)]
        public VkBuffer buffer;
        [FieldOffset(8)]
        public ulong offset;
        [FieldOffset(16)]
        public ulong range;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkDescriptorImageInfo {
        [FieldOffset(0)]
        public VkSampler sampler;
        [FieldOffset(8)]
        public VkImageView imageView;
        [FieldOffset(16)]
        public VkImageLayout imageLayout;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkWriteDescriptorSet {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDescriptorSet dstSet;
        [FieldOffset(24)]
        public uint dstBinding;
        [FieldOffset(28)]
        public uint dstArrayElement;
        [FieldOffset(32)]
        public uint descriptorCount;
        [FieldOffset(36)]
        public VkDescriptorType descriptorType;
        [FieldOffset(40)]
        public IntPtr pImageInfo;
        [FieldOffset(48)]
        public IntPtr pBufferInfo;
        [FieldOffset(56)]
        public IntPtr pTexelBufferView;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkCopyDescriptorSet {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDescriptorSet srcSet;
        [FieldOffset(24)]
        public uint srcBinding;
        [FieldOffset(28)]
        public uint srcArrayElement;
        [FieldOffset(32)]
        public VkDescriptorSet dstSet;
        [FieldOffset(40)]
        public uint dstBinding;
        [FieldOffset(44)]
        public uint dstArrayElement;
        [FieldOffset(48)]
        public uint descriptorCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkBufferCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkBufferCreateFlags flags;
        [FieldOffset(24)]
        public ulong size;
        [FieldOffset(32)]
        public VkBufferUsageFlags usage;
        [FieldOffset(36)]
        public VkSharingMode sharingMode;
        [FieldOffset(40)]
        public uint queueFamilyIndexCount;
        [FieldOffset(48)]
        public IntPtr pQueueFamilyIndices;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkBufferViewCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkBufferViewCreateFlags flags;
        [FieldOffset(24)]
        public VkBuffer buffer;
        [FieldOffset(32)]
        public VkFormat format;
        [FieldOffset(40)]
        public ulong offset;
        [FieldOffset(48)]
        public ulong range;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkImageSubresource {
        [FieldOffset(0)]
        public VkImageAspectFlags aspectMask;
        [FieldOffset(4)]
        public uint mipLevel;
        [FieldOffset(8)]
        public uint arrayLayer;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkImageSubresourceLayers {
        [FieldOffset(0)]
        public VkImageAspectFlags aspectMask;
        [FieldOffset(4)]
        public uint mipLevel;
        [FieldOffset(8)]
        public uint baseArrayLayer;
        [FieldOffset(12)]
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct VkImageSubresourceRange {
        [FieldOffset(0)]
        public VkImageAspectFlags aspectMask;
        [FieldOffset(4)]
        public uint baseMipLevel;
        [FieldOffset(8)]
        public uint levelCount;
        [FieldOffset(12)]
        public uint baseArrayLayer;
        [FieldOffset(16)]
        public uint layerCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkMemoryBarrier {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkAccessFlags srcAccessMask;
        [FieldOffset(20)]
        public VkAccessFlags dstAccessMask;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkBufferMemoryBarrier {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkAccessFlags srcAccessMask;
        [FieldOffset(20)]
        public VkAccessFlags dstAccessMask;
        [FieldOffset(24)]
        public uint srcQueueFamilyIndex;
        [FieldOffset(28)]
        public uint dstQueueFamilyIndex;
        [FieldOffset(32)]
        public VkBuffer buffer;
        [FieldOffset(40)]
        public ulong offset;
        [FieldOffset(48)]
        public ulong size;
    }

    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct VkImageMemoryBarrier {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkAccessFlags srcAccessMask;
        [FieldOffset(20)]
        public VkAccessFlags dstAccessMask;
        [FieldOffset(24)]
        public VkImageLayout oldLayout;
        [FieldOffset(28)]
        public VkImageLayout newLayout;
        [FieldOffset(32)]
        public uint srcQueueFamilyIndex;
        [FieldOffset(36)]
        public uint dstQueueFamilyIndex;
        [FieldOffset(40)]
        public VkImage image;
        [FieldOffset(48)]
        public VkImageSubresourceRange subresourceRange;
    }

    [StructLayout(LayoutKind.Explicit, Size = 88)]
    public partial struct VkImageCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkImageCreateFlags flags;
        [FieldOffset(20)]
        public VkImageType imageType;
        [FieldOffset(24)]
        public VkFormat format;
        [FieldOffset(28)]
        public VkExtent3D extent;
        [FieldOffset(40)]
        public uint mipLevels;
        [FieldOffset(44)]
        public uint arrayLayers;
        [FieldOffset(48)]
        public VkSampleCountFlags samples;
        [FieldOffset(52)]
        public VkImageTiling tiling;
        [FieldOffset(56)]
        public VkImageUsageFlags usage;
        [FieldOffset(60)]
        public VkSharingMode sharingMode;
        [FieldOffset(64)]
        public uint queueFamilyIndexCount;
        [FieldOffset(72)]
        public IntPtr pQueueFamilyIndices;
        [FieldOffset(80)]
        public VkImageLayout initialLayout;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkSubresourceLayout {
        [FieldOffset(0)]
        public ulong offset;
        [FieldOffset(8)]
        public ulong size;
        [FieldOffset(16)]
        public ulong rowPitch;
        [FieldOffset(24)]
        public ulong arrayPitch;
        [FieldOffset(32)]
        public ulong depthPitch;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct VkImageViewCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkImageViewCreateFlags flags;
        [FieldOffset(24)]
        public VkImage image;
        [FieldOffset(32)]
        public VkImageViewType viewType;
        [FieldOffset(36)]
        public VkFormat format;
        [FieldOffset(40)]
        public VkComponentMapping components;
        [FieldOffset(56)]
        public VkImageSubresourceRange subresourceRange;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkBufferCopy {
        [FieldOffset(0)]
        public ulong srcOffset;
        [FieldOffset(8)]
        public ulong dstOffset;
        [FieldOffset(16)]
        public ulong size;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkSparseMemoryBind {
        [FieldOffset(0)]
        public ulong resourceOffset;
        [FieldOffset(8)]
        public ulong size;
        [FieldOffset(16)]
        public VkDeviceMemory memory;
        [FieldOffset(24)]
        public ulong memoryOffset;
        [FieldOffset(32)]
        public VkSparseMemoryBindFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkSparseImageMemoryBind {
        [FieldOffset(0)]
        public VkImageSubresource subresource;
        [FieldOffset(12)]
        public VkOffset3D offset;
        [FieldOffset(24)]
        public VkExtent3D extent;
        [FieldOffset(40)]
        public VkDeviceMemory memory;
        [FieldOffset(48)]
        public ulong memoryOffset;
        [FieldOffset(56)]
        public VkSparseMemoryBindFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkSparseBufferMemoryBindInfo {
        [FieldOffset(0)]
        public VkBuffer buffer;
        [FieldOffset(8)]
        public uint bindCount;
        [FieldOffset(16)]
        public IntPtr pBinds;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkSparseImageOpaqueMemoryBindInfo {
        [FieldOffset(0)]
        public VkImage image;
        [FieldOffset(8)]
        public uint bindCount;
        [FieldOffset(16)]
        public IntPtr pBinds;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkSparseImageMemoryBindInfo {
        [FieldOffset(0)]
        public VkImage image;
        [FieldOffset(8)]
        public uint bindCount;
        [FieldOffset(16)]
        public IntPtr pBinds;
    }

    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct VkBindSparseInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public uint waitSemaphoreCount;
        [FieldOffset(24)]
        public IntPtr pWaitSemaphores;
        [FieldOffset(32)]
        public uint bufferBindCount;
        [FieldOffset(40)]
        public IntPtr pBufferBinds;
        [FieldOffset(48)]
        public uint imageOpaqueBindCount;
        [FieldOffset(56)]
        public IntPtr pImageOpaqueBinds;
        [FieldOffset(64)]
        public uint imageBindCount;
        [FieldOffset(72)]
        public IntPtr pImageBinds;
        [FieldOffset(80)]
        public uint signalSemaphoreCount;
        [FieldOffset(88)]
        public IntPtr pSignalSemaphores;
    }

    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public partial struct VkImageCopy {
        [FieldOffset(0)]
        public VkImageSubresourceLayers srcSubresource;
        [FieldOffset(16)]
        public VkOffset3D srcOffset;
        [FieldOffset(28)]
        public VkImageSubresourceLayers dstSubresource;
        [FieldOffset(44)]
        public VkOffset3D dstOffset;
        [FieldOffset(56)]
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct VkImageBlit {
        [FieldOffset(0)]
        public VkImageSubresourceLayers srcSubresource;
        [FieldOffset(16)]
        public VkOffset3D srcOffsets_0;
        [FieldOffset(28)]
        public VkOffset3D srcOffsets_1;

        public VkOffset3D GetSrcOffsets(int i) {
            switch (i) {
                case 0: return srcOffsets_0;
                case 1: return srcOffsets_1;
                default: return default(VkOffset3D);
            }
        }

        public void SetSrcOffsets(int i, VkOffset3D value) {
            switch (i) {
                case 0: srcOffsets_0 = value; break;
                case 1: srcOffsets_1 = value; break;
                default: return;
            }
        }
        [FieldOffset(40)]
        public VkImageSubresourceLayers dstSubresource;
        [FieldOffset(56)]
        public VkOffset3D dstOffsets_0;
        [FieldOffset(68)]
        public VkOffset3D dstOffsets_1;

        public VkOffset3D GetDstOffsets(int i) {
            switch (i) {
                case 0: return dstOffsets_0;
                case 1: return dstOffsets_1;
                default: return default(VkOffset3D);
            }
        }

        public void SetDstOffsets(int i, VkOffset3D value) {
            switch (i) {
                case 0: dstOffsets_0 = value; break;
                case 1: dstOffsets_1 = value; break;
                default: return;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkBufferImageCopy {
        [FieldOffset(0)]
        public ulong bufferOffset;
        [FieldOffset(8)]
        public uint bufferRowLength;
        [FieldOffset(12)]
        public uint bufferImageHeight;
        [FieldOffset(16)]
        public VkImageSubresourceLayers imageSubresource;
        [FieldOffset(32)]
        public VkOffset3D imageOffset;
        [FieldOffset(44)]
        public VkExtent3D imageExtent;
    }

    [StructLayout(LayoutKind.Explicit, Size = 68)]
    public partial struct VkImageResolve {
        [FieldOffset(0)]
        public VkImageSubresourceLayers srcSubresource;
        [FieldOffset(16)]
        public VkOffset3D srcOffset;
        [FieldOffset(28)]
        public VkImageSubresourceLayers dstSubresource;
        [FieldOffset(44)]
        public VkOffset3D dstOffset;
        [FieldOffset(56)]
        public VkExtent3D extent;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkShaderModuleCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkShaderModuleCreateFlags flags;
        [FieldOffset(24)]
        public IntPtr codeSize;
        [FieldOffset(32)]
        public IntPtr pCode;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkDescriptorSetLayoutBinding {
        [FieldOffset(0)]
        public uint binding;
        [FieldOffset(4)]
        public VkDescriptorType descriptorType;
        [FieldOffset(8)]
        public uint descriptorCount;
        [FieldOffset(12)]
        public VkShaderStageFlags stageFlags;
        [FieldOffset(16)]
        public IntPtr pImmutableSamplers;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkDescriptorSetLayoutCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDescriptorSetLayoutCreateFlags flags;
        [FieldOffset(20)]
        public uint bindingCount;
        [FieldOffset(24)]
        public IntPtr pBindings;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkDescriptorPoolSize {
        [FieldOffset(0)]
        public VkDescriptorType type;
        [FieldOffset(4)]
        public uint descriptorCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkDescriptorPoolCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDescriptorPoolCreateFlags flags;
        [FieldOffset(20)]
        public uint maxSets;
        [FieldOffset(24)]
        public uint poolSizeCount;
        [FieldOffset(32)]
        public IntPtr pPoolSizes;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkDescriptorSetAllocateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDescriptorPool descriptorPool;
        [FieldOffset(24)]
        public uint descriptorSetCount;
        [FieldOffset(32)]
        public IntPtr pSetLayouts;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkSpecializationMapEntry {
        [FieldOffset(0)]
        public uint constantID;
        [FieldOffset(4)]
        public uint offset;
        [FieldOffset(8)]
        public IntPtr size;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkSpecializationInfo {
        [FieldOffset(0)]
        public uint mapEntryCount;
        [FieldOffset(8)]
        public IntPtr pMapEntries;
        [FieldOffset(16)]
        public IntPtr dataSize;
        [FieldOffset(24)]
        public IntPtr pData;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkPipelineShaderStageCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineShaderStageCreateFlags flags;
        [FieldOffset(20)]
        public VkShaderStageFlags stage;
        [FieldOffset(24)]
        public VkShaderModule module;
        [FieldOffset(32)]
        public IntPtr pName;
        [FieldOffset(40)]
        public IntPtr pSpecializationInfo;
    }

    [StructLayout(LayoutKind.Explicit, Size = 96)]
    public partial struct VkComputePipelineCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineCreateFlags flags;
        [FieldOffset(24)]
        public VkPipelineShaderStageCreateInfo stage;
        [FieldOffset(72)]
        public VkPipelineLayout layout;
        [FieldOffset(80)]
        public VkPipeline basePipelineHandle;
        [FieldOffset(88)]
        public int basePipelineIndex;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkVertexInputBindingDescription {
        [FieldOffset(0)]
        public uint binding;
        [FieldOffset(4)]
        public uint stride;
        [FieldOffset(8)]
        public VkVertexInputRate inputRate;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkVertexInputAttributeDescription {
        [FieldOffset(0)]
        public uint location;
        [FieldOffset(4)]
        public uint binding;
        [FieldOffset(8)]
        public VkFormat format;
        [FieldOffset(12)]
        public uint offset;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkPipelineVertexInputStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineVertexInputStateCreateFlags flags;
        [FieldOffset(20)]
        public uint vertexBindingDescriptionCount;
        [FieldOffset(24)]
        public IntPtr pVertexBindingDescriptions;
        [FieldOffset(32)]
        public uint vertexAttributeDescriptionCount;
        [FieldOffset(40)]
        public IntPtr pVertexAttributeDescriptions;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkPipelineInputAssemblyStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineInputAssemblyStateCreateFlags flags;
        [FieldOffset(20)]
        public VkPrimitiveTopology topology;
        [FieldOffset(24)]
        public uint primitiveRestartEnable;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkPipelineTessellationStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineTessellationStateCreateFlags flags;
        [FieldOffset(20)]
        public uint patchControlPoints;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkPipelineViewportStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineViewportStateCreateFlags flags;
        [FieldOffset(20)]
        public uint viewportCount;
        [FieldOffset(24)]
        public IntPtr pViewports;
        [FieldOffset(32)]
        public uint scissorCount;
        [FieldOffset(40)]
        public IntPtr pScissors;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkPipelineRasterizationStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineRasterizationStateCreateFlags flags;
        [FieldOffset(20)]
        public uint depthClampEnable;
        [FieldOffset(24)]
        public uint rasterizerDiscardEnable;
        [FieldOffset(28)]
        public VkPolygonMode polygonMode;
        [FieldOffset(32)]
        public VkCullModeFlags cullMode;
        [FieldOffset(36)]
        public VkFrontFace frontFace;
        [FieldOffset(40)]
        public uint depthBiasEnable;
        [FieldOffset(44)]
        public float depthBiasConstantFactor;
        [FieldOffset(48)]
        public float depthBiasClamp;
        [FieldOffset(52)]
        public float depthBiasSlopeFactor;
        [FieldOffset(56)]
        public float lineWidth;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkPipelineMultisampleStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineMultisampleStateCreateFlags flags;
        [FieldOffset(20)]
        public VkSampleCountFlags rasterizationSamples;
        [FieldOffset(24)]
        public uint sampleShadingEnable;
        [FieldOffset(28)]
        public float minSampleShading;
        [FieldOffset(32)]
        public IntPtr pSampleMask;
        [FieldOffset(40)]
        public uint alphaToCoverageEnable;
        [FieldOffset(44)]
        public uint alphaToOneEnable;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkPipelineColorBlendAttachmentState {
        [FieldOffset(0)]
        public uint blendEnable;
        [FieldOffset(4)]
        public VkBlendFactor srcColorBlendFactor;
        [FieldOffset(8)]
        public VkBlendFactor dstColorBlendFactor;
        [FieldOffset(12)]
        public VkBlendOp colorBlendOp;
        [FieldOffset(16)]
        public VkBlendFactor srcAlphaBlendFactor;
        [FieldOffset(20)]
        public VkBlendFactor dstAlphaBlendFactor;
        [FieldOffset(24)]
        public VkBlendOp alphaBlendOp;
        [FieldOffset(28)]
        public VkColorComponentFlags colorWriteMask;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkPipelineColorBlendStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineColorBlendStateCreateFlags flags;
        [FieldOffset(20)]
        public uint logicOpEnable;
        [FieldOffset(24)]
        public VkLogicOp logicOp;
        [FieldOffset(28)]
        public uint attachmentCount;
        [FieldOffset(32)]
        public IntPtr pAttachments;
        [FieldOffset(40)]
        public float blendConstants_0;
        [FieldOffset(44)]
        public float blendConstants_1;
        [FieldOffset(48)]
        public float blendConstants_2;
        [FieldOffset(52)]
        public float blendConstants_3;

        public float GetBlendConstants(int i) {
            switch (i) {
                case 0: return blendConstants_0;
                case 1: return blendConstants_1;
                case 2: return blendConstants_2;
                case 3: return blendConstants_3;
                default: return default(float);
            }
        }

        public void SetBlendConstants(int i, float value) {
            switch (i) {
                case 0: blendConstants_0 = value; break;
                case 1: blendConstants_1 = value; break;
                case 2: blendConstants_2 = value; break;
                case 3: blendConstants_3 = value; break;
                default: return;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkPipelineDynamicStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineDynamicStateCreateFlags flags;
        [FieldOffset(20)]
        public uint dynamicStateCount;
        [FieldOffset(24)]
        public IntPtr pDynamicStates;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public partial struct VkStencilOpState {
        [FieldOffset(0)]
        public VkStencilOp failOp;
        [FieldOffset(4)]
        public VkStencilOp passOp;
        [FieldOffset(8)]
        public VkStencilOp depthFailOp;
        [FieldOffset(12)]
        public VkCompareOp compareOp;
        [FieldOffset(16)]
        public uint compareMask;
        [FieldOffset(20)]
        public uint writeMask;
        [FieldOffset(24)]
        public uint reference;
    }

    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public partial struct VkPipelineDepthStencilStateCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineDepthStencilStateCreateFlags flags;
        [FieldOffset(20)]
        public uint depthTestEnable;
        [FieldOffset(24)]
        public uint depthWriteEnable;
        [FieldOffset(28)]
        public VkCompareOp depthCompareOp;
        [FieldOffset(32)]
        public uint depthBoundsTestEnable;
        [FieldOffset(36)]
        public uint stencilTestEnable;
        [FieldOffset(40)]
        public VkStencilOpState front;
        [FieldOffset(68)]
        public VkStencilOpState back;
        [FieldOffset(96)]
        public float minDepthBounds;
        [FieldOffset(100)]
        public float maxDepthBounds;
    }

    [StructLayout(LayoutKind.Explicit, Size = 144)]
    public partial struct VkGraphicsPipelineCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineCreateFlags flags;
        [FieldOffset(20)]
        public uint stageCount;
        [FieldOffset(24)]
        public IntPtr pStages;
        [FieldOffset(32)]
        public IntPtr pVertexInputState;
        [FieldOffset(40)]
        public IntPtr pInputAssemblyState;
        [FieldOffset(48)]
        public IntPtr pTessellationState;
        [FieldOffset(56)]
        public IntPtr pViewportState;
        [FieldOffset(64)]
        public IntPtr pRasterizationState;
        [FieldOffset(72)]
        public IntPtr pMultisampleState;
        [FieldOffset(80)]
        public IntPtr pDepthStencilState;
        [FieldOffset(88)]
        public IntPtr pColorBlendState;
        [FieldOffset(96)]
        public IntPtr pDynamicState;
        [FieldOffset(104)]
        public VkPipelineLayout layout;
        [FieldOffset(112)]
        public VkRenderPass renderPass;
        [FieldOffset(120)]
        public uint subpass;
        [FieldOffset(128)]
        public VkPipeline basePipelineHandle;
        [FieldOffset(136)]
        public int basePipelineIndex;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkPipelineCacheCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineCacheCreateFlags flags;
        [FieldOffset(24)]
        public IntPtr initialDataSize;
        [FieldOffset(32)]
        public IntPtr pInitialData;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkPushConstantRange {
        [FieldOffset(0)]
        public VkShaderStageFlags stageFlags;
        [FieldOffset(4)]
        public uint offset;
        [FieldOffset(8)]
        public uint size;
    }

    [StructLayout(LayoutKind.Explicit, Size = 48)]
    public partial struct VkPipelineLayoutCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkPipelineLayoutCreateFlags flags;
        [FieldOffset(20)]
        public uint setLayoutCount;
        [FieldOffset(24)]
        public IntPtr pSetLayouts;
        [FieldOffset(32)]
        public uint pushConstantRangeCount;
        [FieldOffset(40)]
        public IntPtr pPushConstantRanges;
    }

    [StructLayout(LayoutKind.Explicit, Size = 80)]
    public partial struct VkSamplerCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkSamplerCreateFlags flags;
        [FieldOffset(20)]
        public VkFilter magFilter;
        [FieldOffset(24)]
        public VkFilter minFilter;
        [FieldOffset(28)]
        public VkSamplerMipmapMode mipmapMode;
        [FieldOffset(32)]
        public VkSamplerAddressMode addressModeU;
        [FieldOffset(36)]
        public VkSamplerAddressMode addressModeV;
        [FieldOffset(40)]
        public VkSamplerAddressMode addressModeW;
        [FieldOffset(44)]
        public float mipLodBias;
        [FieldOffset(48)]
        public uint anisotropyEnable;
        [FieldOffset(52)]
        public float maxAnisotropy;
        [FieldOffset(56)]
        public uint compareEnable;
        [FieldOffset(60)]
        public VkCompareOp compareOp;
        [FieldOffset(64)]
        public float minLod;
        [FieldOffset(68)]
        public float maxLod;
        [FieldOffset(72)]
        public VkBorderColor borderColor;
        [FieldOffset(76)]
        public uint unnormalizedCoordinates;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkCommandPoolCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkCommandPoolCreateFlags flags;
        [FieldOffset(20)]
        public uint queueFamilyIndex;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkCommandBufferAllocateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkCommandPool commandPool;
        [FieldOffset(24)]
        public VkCommandBufferLevel level;
        [FieldOffset(28)]
        public uint commandBufferCount;
    }

    [StructLayout(LayoutKind.Explicit, Size = 56)]
    public partial struct VkCommandBufferInheritanceInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkRenderPass renderPass;
        [FieldOffset(24)]
        public uint subpass;
        [FieldOffset(32)]
        public VkFramebuffer framebuffer;
        [FieldOffset(40)]
        public uint occlusionQueryEnable;
        [FieldOffset(44)]
        public VkQueryControlFlags queryFlags;
        [FieldOffset(48)]
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkCommandBufferBeginInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkCommandBufferUsageFlags flags;
        [FieldOffset(24)]
        public IntPtr pInheritanceInfo;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkRenderPassBeginInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkRenderPass renderPass;
        [FieldOffset(24)]
        public VkFramebuffer framebuffer;
        [FieldOffset(32)]
        public VkRect2D renderArea;
        [FieldOffset(48)]
        public uint clearValueCount;
        [FieldOffset(56)]
        public IntPtr pClearValues;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkClearColorValue {
        [FieldOffset(0)]
        public float float32_0;
        [FieldOffset(4)]
        public float float32_1;
        [FieldOffset(8)]
        public float float32_2;
        [FieldOffset(12)]
        public float float32_3;

        public float GetFloat32(int i) {
            switch (i) {
                case 0: return float32_0;
                case 1: return float32_1;
                case 2: return float32_2;
                case 3: return float32_3;
                default: return default(float);
            }
        }

        public void SetFloat32(int i, float value) {
            switch (i) {
                case 0: float32_0 = value; break;
                case 1: float32_1 = value; break;
                case 2: float32_2 = value; break;
                case 3: float32_3 = value; break;
                default: return;
            }
        }
        [FieldOffset(0)]
        public int int32_0;
        [FieldOffset(4)]
        public int int32_1;
        [FieldOffset(8)]
        public int int32_2;
        [FieldOffset(12)]
        public int int32_3;

        public int GetInt32(int i) {
            switch (i) {
                case 0: return int32_0;
                case 1: return int32_1;
                case 2: return int32_2;
                case 3: return int32_3;
                default: return default(int);
            }
        }

        public void SetInt32(int i, int value) {
            switch (i) {
                case 0: int32_0 = value; break;
                case 1: int32_1 = value; break;
                case 2: int32_2 = value; break;
                case 3: int32_3 = value; break;
                default: return;
            }
        }
        [FieldOffset(0)]
        public uint uint32_0;
        [FieldOffset(4)]
        public uint uint32_1;
        [FieldOffset(8)]
        public uint uint32_2;
        [FieldOffset(12)]
        public uint uint32_3;

        public uint GetUint32(int i) {
            switch (i) {
                case 0: return uint32_0;
                case 1: return uint32_1;
                case 2: return uint32_2;
                case 3: return uint32_3;
                default: return default(uint);
            }
        }

        public void SetUint32(int i, uint value) {
            switch (i) {
                case 0: uint32_0 = value; break;
                case 1: uint32_1 = value; break;
                case 2: uint32_2 = value; break;
                case 3: uint32_3 = value; break;
                default: return;
            }
        }
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkClearDepthStencilValue {
        [FieldOffset(0)]
        public float depth;
        [FieldOffset(4)]
        public uint stencil;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkClearValue {
        [FieldOffset(0)]
        public VkClearColorValue color;
        [FieldOffset(0)]
        public VkClearDepthStencilValue depthStencil;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkClearAttachment {
        [FieldOffset(0)]
        public VkImageAspectFlags aspectMask;
        [FieldOffset(4)]
        public uint colorAttachment;
        [FieldOffset(8)]
        public VkClearValue clearValue;
    }

    [StructLayout(LayoutKind.Explicit, Size = 36)]
    public partial struct VkAttachmentDescription {
        [FieldOffset(0)]
        public VkAttachmentDescriptionFlags flags;
        [FieldOffset(4)]
        public VkFormat format;
        [FieldOffset(8)]
        public VkSampleCountFlags samples;
        [FieldOffset(12)]
        public VkAttachmentLoadOp loadOp;
        [FieldOffset(16)]
        public VkAttachmentStoreOp storeOp;
        [FieldOffset(20)]
        public VkAttachmentLoadOp stencilLoadOp;
        [FieldOffset(24)]
        public VkAttachmentStoreOp stencilStoreOp;
        [FieldOffset(28)]
        public VkImageLayout initialLayout;
        [FieldOffset(32)]
        public VkImageLayout finalLayout;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkAttachmentReference {
        [FieldOffset(0)]
        public uint attachment;
        [FieldOffset(4)]
        public VkImageLayout layout;
    }

    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct VkSubpassDescription {
        [FieldOffset(0)]
        public VkSubpassDescriptionFlags flags;
        [FieldOffset(4)]
        public VkPipelineBindPoint pipelineBindPoint;
        [FieldOffset(8)]
        public uint inputAttachmentCount;
        [FieldOffset(16)]
        public IntPtr pInputAttachments;
        [FieldOffset(24)]
        public uint colorAttachmentCount;
        [FieldOffset(32)]
        public IntPtr pColorAttachments;
        [FieldOffset(40)]
        public IntPtr pResolveAttachments;
        [FieldOffset(48)]
        public IntPtr pDepthStencilAttachment;
        [FieldOffset(56)]
        public uint preserveAttachmentCount;
        [FieldOffset(64)]
        public IntPtr pPreserveAttachments;
    }

    [StructLayout(LayoutKind.Explicit, Size = 28)]
    public partial struct VkSubpassDependency {
        [FieldOffset(0)]
        public uint srcSubpass;
        [FieldOffset(4)]
        public uint dstSubpass;
        [FieldOffset(8)]
        public VkPipelineStageFlags srcStageMask;
        [FieldOffset(12)]
        public VkPipelineStageFlags dstStageMask;
        [FieldOffset(16)]
        public VkAccessFlags srcAccessMask;
        [FieldOffset(20)]
        public VkAccessFlags dstAccessMask;
        [FieldOffset(24)]
        public VkDependencyFlags dependencyFlags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkRenderPassCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkRenderPassCreateFlags flags;
        [FieldOffset(20)]
        public uint attachmentCount;
        [FieldOffset(24)]
        public IntPtr pAttachments;
        [FieldOffset(32)]
        public uint subpassCount;
        [FieldOffset(40)]
        public IntPtr pSubpasses;
        [FieldOffset(48)]
        public uint dependencyCount;
        [FieldOffset(56)]
        public IntPtr pDependencies;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkEventCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkEventCreateFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkFenceCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkFenceCreateFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 220)]
    public partial struct VkPhysicalDeviceFeatures {
        [FieldOffset(0)]
        public uint robustBufferAccess;
        [FieldOffset(4)]
        public uint fullDrawIndexUint32;
        [FieldOffset(8)]
        public uint imageCubeArray;
        [FieldOffset(12)]
        public uint independentBlend;
        [FieldOffset(16)]
        public uint geometryShader;
        [FieldOffset(20)]
        public uint tessellationShader;
        [FieldOffset(24)]
        public uint sampleRateShading;
        [FieldOffset(28)]
        public uint dualSrcBlend;
        [FieldOffset(32)]
        public uint logicOp;
        [FieldOffset(36)]
        public uint multiDrawIndirect;
        [FieldOffset(40)]
        public uint drawIndirectFirstInstance;
        [FieldOffset(44)]
        public uint depthClamp;
        [FieldOffset(48)]
        public uint depthBiasClamp;
        [FieldOffset(52)]
        public uint fillModeNonSolid;
        [FieldOffset(56)]
        public uint depthBounds;
        [FieldOffset(60)]
        public uint wideLines;
        [FieldOffset(64)]
        public uint largePoints;
        [FieldOffset(68)]
        public uint alphaToOne;
        [FieldOffset(72)]
        public uint multiViewport;
        [FieldOffset(76)]
        public uint samplerAnisotropy;
        [FieldOffset(80)]
        public uint textureCompressionETC2;
        [FieldOffset(84)]
        public uint textureCompressionASTC_LDR;
        [FieldOffset(88)]
        public uint textureCompressionBC;
        [FieldOffset(92)]
        public uint occlusionQueryPrecise;
        [FieldOffset(96)]
        public uint pipelineStatisticsQuery;
        [FieldOffset(100)]
        public uint vertexPipelineStoresAndAtomics;
        [FieldOffset(104)]
        public uint fragmentStoresAndAtomics;
        [FieldOffset(108)]
        public uint shaderTessellationAndGeometryPointSize;
        [FieldOffset(112)]
        public uint shaderImageGatherExtended;
        [FieldOffset(116)]
        public uint shaderStorageImageExtendedFormats;
        [FieldOffset(120)]
        public uint shaderStorageImageMultisample;
        [FieldOffset(124)]
        public uint shaderStorageImageReadWithoutFormat;
        [FieldOffset(128)]
        public uint shaderStorageImageWriteWithoutFormat;
        [FieldOffset(132)]
        public uint shaderUniformBufferArrayDynamicIndexing;
        [FieldOffset(136)]
        public uint shaderSampledImageArrayDynamicIndexing;
        [FieldOffset(140)]
        public uint shaderStorageBufferArrayDynamicIndexing;
        [FieldOffset(144)]
        public uint shaderStorageImageArrayDynamicIndexing;
        [FieldOffset(148)]
        public uint shaderClipDistance;
        [FieldOffset(152)]
        public uint shaderCullDistance;
        [FieldOffset(156)]
        public uint shaderFloat64;
        [FieldOffset(160)]
        public uint shaderInt64;
        [FieldOffset(164)]
        public uint shaderInt16;
        [FieldOffset(168)]
        public uint shaderResourceResidency;
        [FieldOffset(172)]
        public uint shaderResourceMinLod;
        [FieldOffset(176)]
        public uint sparseBinding;
        [FieldOffset(180)]
        public uint sparseResidencyBuffer;
        [FieldOffset(184)]
        public uint sparseResidencyImage2D;
        [FieldOffset(188)]
        public uint sparseResidencyImage3D;
        [FieldOffset(192)]
        public uint sparseResidency2Samples;
        [FieldOffset(196)]
        public uint sparseResidency4Samples;
        [FieldOffset(200)]
        public uint sparseResidency8Samples;
        [FieldOffset(204)]
        public uint sparseResidency16Samples;
        [FieldOffset(208)]
        public uint sparseResidencyAliased;
        [FieldOffset(212)]
        public uint variableMultisampleRate;
        [FieldOffset(216)]
        public uint inheritedQueries;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct VkPhysicalDeviceSparseProperties {
        [FieldOffset(0)]
        public uint residencyStandard2DBlockShape;
        [FieldOffset(4)]
        public uint residencyStandard2DMultisampleBlockShape;
        [FieldOffset(8)]
        public uint residencyStandard3DBlockShape;
        [FieldOffset(12)]
        public uint residencyAlignedMipSize;
        [FieldOffset(16)]
        public uint residencyNonResidentStrict;
    }

    [StructLayout(LayoutKind.Explicit, Size = 504)]
    public partial struct VkPhysicalDeviceLimits {
        [FieldOffset(0)]
        public uint maxImageDimension1D;
        [FieldOffset(4)]
        public uint maxImageDimension2D;
        [FieldOffset(8)]
        public uint maxImageDimension3D;
        [FieldOffset(12)]
        public uint maxImageDimensionCube;
        [FieldOffset(16)]
        public uint maxImageArrayLayers;
        [FieldOffset(20)]
        public uint maxTexelBufferElements;
        [FieldOffset(24)]
        public uint maxUniformBufferRange;
        [FieldOffset(28)]
        public uint maxStorageBufferRange;
        [FieldOffset(32)]
        public uint maxPushConstantsSize;
        [FieldOffset(36)]
        public uint maxMemoryAllocationCount;
        [FieldOffset(40)]
        public uint maxSamplerAllocationCount;
        [FieldOffset(48)]
        public ulong bufferImageGranularity;
        [FieldOffset(56)]
        public ulong sparseAddressSpaceSize;
        [FieldOffset(64)]
        public uint maxBoundDescriptorSets;
        [FieldOffset(68)]
        public uint maxPerStageDescriptorSamplers;
        [FieldOffset(72)]
        public uint maxPerStageDescriptorUniformBuffers;
        [FieldOffset(76)]
        public uint maxPerStageDescriptorStorageBuffers;
        [FieldOffset(80)]
        public uint maxPerStageDescriptorSampledImages;
        [FieldOffset(84)]
        public uint maxPerStageDescriptorStorageImages;
        [FieldOffset(88)]
        public uint maxPerStageDescriptorInputAttachments;
        [FieldOffset(92)]
        public uint maxPerStageResources;
        [FieldOffset(96)]
        public uint maxDescriptorSetSamplers;
        [FieldOffset(100)]
        public uint maxDescriptorSetUniformBuffers;
        [FieldOffset(104)]
        public uint maxDescriptorSetUniformBuffersDynamic;
        [FieldOffset(108)]
        public uint maxDescriptorSetStorageBuffers;
        [FieldOffset(112)]
        public uint maxDescriptorSetStorageBuffersDynamic;
        [FieldOffset(116)]
        public uint maxDescriptorSetSampledImages;
        [FieldOffset(120)]
        public uint maxDescriptorSetStorageImages;
        [FieldOffset(124)]
        public uint maxDescriptorSetInputAttachments;
        [FieldOffset(128)]
        public uint maxVertexInputAttributes;
        [FieldOffset(132)]
        public uint maxVertexInputBindings;
        [FieldOffset(136)]
        public uint maxVertexInputAttributeOffset;
        [FieldOffset(140)]
        public uint maxVertexInputBindingStride;
        [FieldOffset(144)]
        public uint maxVertexOutputComponents;
        [FieldOffset(148)]
        public uint maxTessellationGenerationLevel;
        [FieldOffset(152)]
        public uint maxTessellationPatchSize;
        [FieldOffset(156)]
        public uint maxTessellationControlPerVertexInputComponents;
        [FieldOffset(160)]
        public uint maxTessellationControlPerVertexOutputComponents;
        [FieldOffset(164)]
        public uint maxTessellationControlPerPatchOutputComponents;
        [FieldOffset(168)]
        public uint maxTessellationControlTotalOutputComponents;
        [FieldOffset(172)]
        public uint maxTessellationEvaluationInputComponents;
        [FieldOffset(176)]
        public uint maxTessellationEvaluationOutputComponents;
        [FieldOffset(180)]
        public uint maxGeometryShaderInvocations;
        [FieldOffset(184)]
        public uint maxGeometryInputComponents;
        [FieldOffset(188)]
        public uint maxGeometryOutputComponents;
        [FieldOffset(192)]
        public uint maxGeometryOutputVertices;
        [FieldOffset(196)]
        public uint maxGeometryTotalOutputComponents;
        [FieldOffset(200)]
        public uint maxFragmentInputComponents;
        [FieldOffset(204)]
        public uint maxFragmentOutputAttachments;
        [FieldOffset(208)]
        public uint maxFragmentDualSrcAttachments;
        [FieldOffset(212)]
        public uint maxFragmentCombinedOutputResources;
        [FieldOffset(216)]
        public uint maxComputeSharedMemorySize;
        [FieldOffset(220)]
        public uint maxComputeWorkGroupCount_0;
        [FieldOffset(224)]
        public uint maxComputeWorkGroupCount_1;
        [FieldOffset(228)]
        public uint maxComputeWorkGroupCount_2;

        public uint GetMaxComputeWorkGroupCount(int i) {
            switch (i) {
                case 0: return maxComputeWorkGroupCount_0;
                case 1: return maxComputeWorkGroupCount_1;
                case 2: return maxComputeWorkGroupCount_2;
                default: return default(uint);
            }
        }

        public void SetMaxComputeWorkGroupCount(int i, uint value) {
            switch (i) {
                case 0: maxComputeWorkGroupCount_0 = value; break;
                case 1: maxComputeWorkGroupCount_1 = value; break;
                case 2: maxComputeWorkGroupCount_2 = value; break;
                default: return;
            }
        }
        [FieldOffset(232)]
        public uint maxComputeWorkGroupInvocations;
        [FieldOffset(236)]
        public uint maxComputeWorkGroupSize_0;
        [FieldOffset(240)]
        public uint maxComputeWorkGroupSize_1;
        [FieldOffset(244)]
        public uint maxComputeWorkGroupSize_2;

        public uint GetMaxComputeWorkGroupSize(int i) {
            switch (i) {
                case 0: return maxComputeWorkGroupSize_0;
                case 1: return maxComputeWorkGroupSize_1;
                case 2: return maxComputeWorkGroupSize_2;
                default: return default(uint);
            }
        }

        public void SetMaxComputeWorkGroupSize(int i, uint value) {
            switch (i) {
                case 0: maxComputeWorkGroupSize_0 = value; break;
                case 1: maxComputeWorkGroupSize_1 = value; break;
                case 2: maxComputeWorkGroupSize_2 = value; break;
                default: return;
            }
        }
        [FieldOffset(248)]
        public uint subPixelPrecisionBits;
        [FieldOffset(252)]
        public uint subTexelPrecisionBits;
        [FieldOffset(256)]
        public uint mipmapPrecisionBits;
        [FieldOffset(260)]
        public uint maxDrawIndexedIndexValue;
        [FieldOffset(264)]
        public uint maxDrawIndirectCount;
        [FieldOffset(268)]
        public float maxSamplerLodBias;
        [FieldOffset(272)]
        public float maxSamplerAnisotropy;
        [FieldOffset(276)]
        public uint maxViewports;
        [FieldOffset(280)]
        public uint maxViewportDimensions_0;
        [FieldOffset(284)]
        public uint maxViewportDimensions_1;

        public uint GetMaxViewportDimensions(int i) {
            switch (i) {
                case 0: return maxViewportDimensions_0;
                case 1: return maxViewportDimensions_1;
                default: return default(uint);
            }
        }

        public void SetMaxViewportDimensions(int i, uint value) {
            switch (i) {
                case 0: maxViewportDimensions_0 = value; break;
                case 1: maxViewportDimensions_1 = value; break;
                default: return;
            }
        }
        [FieldOffset(288)]
        public float viewportBoundsRange_0;
        [FieldOffset(292)]
        public float viewportBoundsRange_1;

        public float GetViewportBoundsRange(int i) {
            switch (i) {
                case 0: return viewportBoundsRange_0;
                case 1: return viewportBoundsRange_1;
                default: return default(float);
            }
        }

        public void SetViewportBoundsRange(int i, float value) {
            switch (i) {
                case 0: viewportBoundsRange_0 = value; break;
                case 1: viewportBoundsRange_1 = value; break;
                default: return;
            }
        }
        [FieldOffset(296)]
        public uint viewportSubPixelBits;
        [FieldOffset(304)]
        public IntPtr minMemoryMapAlignment;
        [FieldOffset(312)]
        public ulong minTexelBufferOffsetAlignment;
        [FieldOffset(320)]
        public ulong minUniformBufferOffsetAlignment;
        [FieldOffset(328)]
        public ulong minStorageBufferOffsetAlignment;
        [FieldOffset(336)]
        public int minTexelOffset;
        [FieldOffset(340)]
        public uint maxTexelOffset;
        [FieldOffset(344)]
        public int minTexelGatherOffset;
        [FieldOffset(348)]
        public uint maxTexelGatherOffset;
        [FieldOffset(352)]
        public float minInterpolationOffset;
        [FieldOffset(356)]
        public float maxInterpolationOffset;
        [FieldOffset(360)]
        public uint subPixelInterpolationOffsetBits;
        [FieldOffset(364)]
        public uint maxFramebufferWidth;
        [FieldOffset(368)]
        public uint maxFramebufferHeight;
        [FieldOffset(372)]
        public uint maxFramebufferLayers;
        [FieldOffset(376)]
        public VkSampleCountFlags framebufferColorSampleCounts;
        [FieldOffset(380)]
        public VkSampleCountFlags framebufferDepthSampleCounts;
        [FieldOffset(384)]
        public VkSampleCountFlags framebufferStencilSampleCounts;
        [FieldOffset(388)]
        public VkSampleCountFlags framebufferNoAttachmentsSampleCounts;
        [FieldOffset(392)]
        public uint maxColorAttachments;
        [FieldOffset(396)]
        public VkSampleCountFlags sampledImageColorSampleCounts;
        [FieldOffset(400)]
        public VkSampleCountFlags sampledImageIntegerSampleCounts;
        [FieldOffset(404)]
        public VkSampleCountFlags sampledImageDepthSampleCounts;
        [FieldOffset(408)]
        public VkSampleCountFlags sampledImageStencilSampleCounts;
        [FieldOffset(412)]
        public VkSampleCountFlags storageImageSampleCounts;
        [FieldOffset(416)]
        public uint maxSampleMaskWords;
        [FieldOffset(420)]
        public uint timestampComputeAndGraphics;
        [FieldOffset(424)]
        public float timestampPeriod;
        [FieldOffset(428)]
        public uint maxClipDistances;
        [FieldOffset(432)]
        public uint maxCullDistances;
        [FieldOffset(436)]
        public uint maxCombinedClipAndCullDistances;
        [FieldOffset(440)]
        public uint discreteQueuePriorities;
        [FieldOffset(444)]
        public float pointSizeRange_0;
        [FieldOffset(448)]
        public float pointSizeRange_1;

        public float GetPointSizeRange(int i) {
            switch (i) {
                case 0: return pointSizeRange_0;
                case 1: return pointSizeRange_1;
                default: return default(float);
            }
        }

        public void SetPointSizeRange(int i, float value) {
            switch (i) {
                case 0: pointSizeRange_0 = value; break;
                case 1: pointSizeRange_1 = value; break;
                default: return;
            }
        }
        [FieldOffset(452)]
        public float lineWidthRange_0;
        [FieldOffset(456)]
        public float lineWidthRange_1;

        public float GetLineWidthRange(int i) {
            switch (i) {
                case 0: return lineWidthRange_0;
                case 1: return lineWidthRange_1;
                default: return default(float);
            }
        }

        public void SetLineWidthRange(int i, float value) {
            switch (i) {
                case 0: lineWidthRange_0 = value; break;
                case 1: lineWidthRange_1 = value; break;
                default: return;
            }
        }
        [FieldOffset(460)]
        public float pointSizeGranularity;
        [FieldOffset(464)]
        public float lineWidthGranularity;
        [FieldOffset(468)]
        public uint strictLines;
        [FieldOffset(472)]
        public uint standardSampleLocations;
        [FieldOffset(480)]
        public ulong optimalBufferCopyOffsetAlignment;
        [FieldOffset(488)]
        public ulong optimalBufferCopyRowPitchAlignment;
        [FieldOffset(496)]
        public ulong nonCoherentAtomSize;
    }

    [StructLayout(LayoutKind.Explicit, Size = 24)]
    public partial struct VkSemaphoreCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkSemaphoreCreateFlags flags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 32)]
    public partial struct VkQueryPoolCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkQueryPoolCreateFlags flags;
        [FieldOffset(20)]
        public VkQueryType queryType;
        [FieldOffset(24)]
        public uint queryCount;
        [FieldOffset(28)]
        public VkQueryPipelineStatisticFlags pipelineStatistics;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkFramebufferCreateInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkFramebufferCreateFlags flags;
        [FieldOffset(24)]
        public VkRenderPass renderPass;
        [FieldOffset(32)]
        public uint attachmentCount;
        [FieldOffset(40)]
        public IntPtr pAttachments;
        [FieldOffset(48)]
        public uint width;
        [FieldOffset(52)]
        public uint height;
        [FieldOffset(56)]
        public uint layers;
    }

    [StructLayout(LayoutKind.Explicit, Size = 16)]
    public partial struct VkDrawIndirectCommand {
        [FieldOffset(0)]
        public uint vertexCount;
        [FieldOffset(4)]
        public uint instanceCount;
        [FieldOffset(8)]
        public uint firstVertex;
        [FieldOffset(12)]
        public uint firstInstance;
    }

    [StructLayout(LayoutKind.Explicit, Size = 20)]
    public partial struct VkDrawIndexedIndirectCommand {
        [FieldOffset(0)]
        public uint indexCount;
        [FieldOffset(4)]
        public uint instanceCount;
        [FieldOffset(8)]
        public uint firstIndex;
        [FieldOffset(12)]
        public int vertexOffset;
        [FieldOffset(16)]
        public uint firstInstance;
    }

    [StructLayout(LayoutKind.Explicit, Size = 12)]
    public partial struct VkDispatchIndirectCommand {
        [FieldOffset(0)]
        public uint x;
        [FieldOffset(4)]
        public uint y;
        [FieldOffset(8)]
        public uint z;
    }

    [StructLayout(LayoutKind.Explicit, Size = 72)]
    public partial struct VkSubmitInfo {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public uint waitSemaphoreCount;
        [FieldOffset(24)]
        public IntPtr pWaitSemaphores;
        [FieldOffset(32)]
        public IntPtr pWaitDstStageMask;
        [FieldOffset(40)]
        public uint commandBufferCount;
        [FieldOffset(48)]
        public IntPtr pCommandBuffers;
        [FieldOffset(56)]
        public uint signalSemaphoreCount;
        [FieldOffset(64)]
        public IntPtr pSignalSemaphores;
    }

    [StructLayout(LayoutKind.Explicit, Size = 52)]
    public partial struct VkSurfaceCapabilitiesKHR {
        [FieldOffset(0)]
        public uint minImageCount;
        [FieldOffset(4)]
        public uint maxImageCount;
        [FieldOffset(8)]
        public VkExtent2D currentExtent;
        [FieldOffset(16)]
        public VkExtent2D minImageExtent;
        [FieldOffset(24)]
        public VkExtent2D maxImageExtent;
        [FieldOffset(32)]
        public uint maxImageArrayLayers;
        [FieldOffset(36)]
        public VkSurfaceTransformFlagsKHR supportedTransforms;
        [FieldOffset(40)]
        public VkSurfaceTransformFlagsKHR currentTransform;
        [FieldOffset(44)]
        public VkCompositeAlphaFlagsKHR supportedCompositeAlpha;
        [FieldOffset(48)]
        public VkImageUsageFlags supportedUsageFlags;
    }

    [StructLayout(LayoutKind.Explicit, Size = 8)]
    public partial struct VkSurfaceFormatKHR {
        [FieldOffset(0)]
        public VkFormat format;
        [FieldOffset(4)]
        public VkColorSpaceKHR colorSpace;
    }

    [StructLayout(LayoutKind.Explicit, Size = 104)]
    public partial struct VkSwapchainCreateInfoKHR {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkSwapchainCreateFlagsKHR flags;
        [FieldOffset(24)]
        public VkSurfaceKHR surface;
        [FieldOffset(32)]
        public uint minImageCount;
        [FieldOffset(36)]
        public VkFormat imageFormat;
        [FieldOffset(40)]
        public VkColorSpaceKHR imageColorSpace;
        [FieldOffset(44)]
        public VkExtent2D imageExtent;
        [FieldOffset(52)]
        public uint imageArrayLayers;
        [FieldOffset(56)]
        public VkImageUsageFlags imageUsage;
        [FieldOffset(60)]
        public VkSharingMode imageSharingMode;
        [FieldOffset(64)]
        public uint queueFamilyIndexCount;
        [FieldOffset(72)]
        public IntPtr pQueueFamilyIndices;
        [FieldOffset(80)]
        public VkSurfaceTransformFlagsKHR preTransform;
        [FieldOffset(84)]
        public VkCompositeAlphaFlagsKHR compositeAlpha;
        [FieldOffset(88)]
        public VkPresentModeKHR presentMode;
        [FieldOffset(92)]
        public uint clipped;
        [FieldOffset(96)]
        public VkSwapchainKHR oldSwapchain;
    }

    [StructLayout(LayoutKind.Explicit, Size = 64)]
    public partial struct VkPresentInfoKHR {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public uint waitSemaphoreCount;
        [FieldOffset(24)]
        public IntPtr pWaitSemaphores;
        [FieldOffset(32)]
        public uint swapchainCount;
        [FieldOffset(40)]
        public IntPtr pSwapchains;
        [FieldOffset(48)]
        public IntPtr pImageIndices;
        [FieldOffset(56)]
        public IntPtr pResults;
    }

    [StructLayout(LayoutKind.Explicit, Size = 40)]
    public partial struct VkDebugReportCallbackCreateInfoEXT {
        [FieldOffset(0)]
        public VkStructureType sType;
        [FieldOffset(8)]
        public IntPtr pNext;
        [FieldOffset(16)]
        public VkDebugReportFlagsEXT flags;
        [FieldOffset(24)]
        public IntPtr pfnCallback;
        [FieldOffset(32)]
        public IntPtr pUserData;
    }

}
